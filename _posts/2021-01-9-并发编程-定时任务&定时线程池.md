---
layout: post
title: 并发编程-定时任务&定时线程池
date: 2021-01-09
categories: java
tags: java 并发编程
---

### ScheduledThreadPoolExecutor

说明：特殊的线程池，在普通线程池上加上了定时功能，所以和线程池的底层模型是一样的。

> ScheduledThreadPoolExecutor继承图

![](https://github.com/zhongzach/zhongzach.github.io/blob/master/assets/img/concurrent/ScheduledThreadPoolExecutor%E7%BB%93%E6%9E%84.png)



> 基本使用案例

```java
ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(1);

// 多久后执行，只会执行一次
executor.schedule(() -> {
    System.out.println("一秒后执行");
},1, TimeUnit.SECONDS);

// 多久后开始执行，每n秒执行一次（同一线程）
executor.scheduleAtFixedRate(() -> {
    System.out.println("send heart");
},1000, 2000,TimeUnit.MILLISECONDS);


// 多久后开始执行，代码块执行完，n秒后再次执行（同一线程）
executor.scheduleWithFixedDelay(() -> {
    System.out.println("send heart");
    try {
        Thread.sleep(3000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
},1000,2000,TimeUnit.MILLISECONDS);
```



> 为何阿里推荐我们使用ScheduledThreadPoolExecutor，不推荐使用Timer?

我们可以从源码入手

Timer

```java
public class Timer {
    /**
     * The timer task queue.  This data structure is shared with the timer
     * thread.  The timer produces tasks, via its various schedule calls,
     * and the timer thread consumes, executing timer tasks as appropriate,
     * and removing them from the queue when they're obsolete.
     */
    private final TaskQueue queue = new TaskQueue();

    /**
     * The timer thread.
     */
    private final TimerThread thread = new TimerThread(queue);
```

实际上，Timer执行任务的时候是内部维护的线程去执行，而当出现异常的时候，线程就会被终止，也就不能够在去执行下一个任务了。而线程池当遇到异常的时候，异常线程会被终止，但是当有新的任务进来的时候，又会重新开启一个新线程去执行任务。

总结：ScheduledThreadPoolExecutor在遇到异常的时候不会导致程序终止退出，而Timer遇到异常是，会直接导致程序终止，这是在生产上面不想看到的。







